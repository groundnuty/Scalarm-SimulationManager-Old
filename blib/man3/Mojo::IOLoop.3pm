.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::IOLoop 3"
.TH Mojo::IOLoop 3 "2013-11-19" "perl v5.16.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::IOLoop \- Minimalistic event loop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::IOLoop;
\&
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input chunk
\&      say $bytes;
\&
\&      # Write response
\&      $stream\->write(\*(AqHTTP/1.1 200 OK\*(Aq);
\&    });
\&  });
\&
\&  # Connect to port 3000
\&  my $id = Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&
\&    $stream\->on(read => sub {
\&      my ($stream, $bytes) = @_;
\&
\&      # Process input
\&      say "Input: $bytes";
\&    });
\&
\&    # Write request
\&    $stream\->write("GET / HTTP/1.1\ex0d\ex0a\ex0d\ex0a");
\&  });
\&
\&  # Add a timer
\&  Mojo::IOLoop\->timer(5 => sub {
\&    my $loop = shift;
\&    $loop\->remove($id);
\&  });
\&
\&  # Start event loop if necessary
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::IOLoop is a very minimalistic event loop based on Mojo::Reactor,
it has been reduced to the absolute minimal feature set required to build
solid and scalable non-blocking \s-1TCP\s0 clients and servers.
.PP
The event loop will be resilient to time jumps if a monotonic clock is
available through Time::HiRes. A \s-1TLS\s0 certificate and key are also built
right in, to make writing test servers as easy as possible. Also note that for
convenience the \f(CW\*(C`PIPE\*(C'\fR signal will be set to \f(CW\*(C`IGNORE\*(C'\fR when Mojo::IOLoop
is loaded.
.PP
For better scalability (epoll, kqueue) and to provide IPv6 as well as \s-1TLS\s0
support, the optional modules \s-1EV\s0 (4.0+), IO::Socket::IP (0.16+) and
IO::Socket::SSL (1.75+) will be used automatically if they are installed.
Individual features can also be disabled with the \s-1MOJO_NO_IPV6\s0 and \s-1MOJO_NO_TLS\s0
environment variables.
.PP
See Mojolicious::Guides::Cookbook for more.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::IOLoop implements the following attributes.
.SS "accept_interval"
.IX Subsection "accept_interval"
.Vb 2
\&  my $interval = $loop\->accept_interval;
\&  $loop        = $loop\->accept_interval(0.5);
.Ve
.PP
Interval in seconds for trying to reacquire the accept mutex, defaults to
\&\f(CW0.025\fR. Note that changing this value can affect performance and idle \s-1CPU\s0
usage.
.SS "lock"
.IX Subsection "lock"
.Vb 2
\&  my $cb = $loop\->lock;
\&  $loop  = $loop\->lock(sub {...});
.Ve
.PP
A callback for acquiring the accept mutex, used to sync multiple server
processes. The callback should return true or false. Note that exceptions in
this callback are not captured.
.PP
.Vb 2
\&  $loop\->lock(sub {
\&    my ($loop, $blocking) = @_;
\&
\&    # Got the accept mutex, start accepting new connections
\&    return 1;
\&  });
.Ve
.SS "max_accepts"
.IX Subsection "max_accepts"
.Vb 2
\&  my $max = $loop\->max_accepts;
\&  $loop   = $loop\->max_accepts(1000);
.Ve
.PP
The maximum number of connections this event loop is allowed to accept before
shutting down gracefully without interrupting existing connections, defaults
to \f(CW0\fR. Setting the value to \f(CW0\fR will allow this event loop to accept new
connections indefinitely. Note that up to half of this value can be subtracted
randomly to improve load balancing between multiple server processes.
.SS "max_connections"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $loop\->max_connections;
\&  $loop   = $loop\->max_connections(1000);
.Ve
.PP
The maximum number of parallel connections this event loop is allowed to
handle before stopping to accept new incoming connections, defaults to
\&\f(CW1000\fR. Setting the value to \f(CW0\fR will make this event loop stop accepting
new connections and allow it to shut down gracefully without interrupting
existing connections.
.SS "multi_accept"
.IX Subsection "multi_accept"
.Vb 2
\&  my $multi = $loop\->multi_accept;
\&  $loop     = $loop\->multi_accept(100);
.Ve
.PP
Number of connections to accept at once, defaults to \f(CW50\fR.
.SS "reactor"
.IX Subsection "reactor"
.Vb 2
\&  my $reactor = $loop\->reactor;
\&  $loop       = $loop\->reactor(Mojo::Reactor\->new);
.Ve
.PP
Low level event reactor, usually a Mojo::Reactor::Poll or
Mojo::Reactor::EV object with a default \f(CW\*(C`error\*(C'\fR event.
.PP
.Vb 5
\&  # Watch if handle becomes readable or writable
\&  $loop\->reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $loop\->reactor\->watch($handle, 0, 1);
.Ve
.SS "unlock"
.IX Subsection "unlock"
.Vb 2
\&  my $cb = $loop\->unlock;
\&  $loop  = $loop\->unlock(sub {...});
.Ve
.PP
A callback for releasing the accept mutex, used to sync multiple server
processes. Note that exceptions in this callback are not captured.
.SH "METHODS"
.IX Header "METHODS"
Mojo::IOLoop inherits all methods from Mojo::Base and implements the
following new ones.
.SS "acceptor"
.IX Subsection "acceptor"
.Vb 3
\&  my $server = Mojo::IOLoop\->acceptor($id);
\&  my $server = $loop\->acceptor($id);
\&  my $id     = $loop\->acceptor(Mojo::IOLoop::Server\->new);
.Ve
.PP
Get Mojo::IOLoop::Server object for id or turn object into an acceptor.
.SS "client"
.IX Subsection "client"
.Vb 4
\&  my $id
\&    = Mojo::IOLoop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client(address => \*(Aq127.0.0.1\*(Aq, port => 3000, sub {...});
\&  my $id = $loop\->client({address => \*(Aq127.0.0.1\*(Aq, port => 3000} => sub {...});
.Ve
.PP
Open \s-1TCP\s0 connection with Mojo::IOLoop::Client, takes the same arguments as
\&\*(L"connect\*(R" in Mojo::IOLoop::Client.
.PP
.Vb 5
\&  # Connect to localhost on port 3000
\&  Mojo::IOLoop\->client({port => 3000} => sub {
\&    my ($loop, $err, $stream) = @_;
\&    ...
\&  });
.Ve
.SS "delay"
.IX Subsection "delay"
.Vb 4
\&  my $delay = Mojo::IOLoop\->delay;
\&  my $delay = $loop\->delay;
\&  my $delay = $loop\->delay(sub {...});
\&  my $delay = $loop\->delay(sub {...}, sub {...});
.Ve
.PP
Get Mojo::IOLoop::Delay object to manage callbacks and control the flow of
events. A single callback will be treated as a subscriber to the \f(CW\*(C`finish\*(C'\fR
event, and multiple ones as a chain of steps.
.PP
.Vb 10
\&  # Synchronize multiple events
\&  my $delay = Mojo::IOLoop\->delay(sub { say \*(AqBOOM!\*(Aq });
\&  for my $i (1 .. 10) {
\&    my $end = $delay\->begin;
\&    Mojo::IOLoop\->timer($i => sub {
\&      say 10 \- $i;
\&      $end\->();
\&    });
\&  }
\&  $delay\->wait unless Mojo::IOLoop\->is_running;
\&
\&  # Sequentialize multiple events
\&  my $delay = Mojo::IOLoop\->delay(
\&
\&    # First step (simple timer)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(2 => $delay\->begin);
\&      say \*(AqSecond step in 2 seconds.\*(Aq;
\&    },
\&
\&    # Second step (parallel timers)
\&    sub {
\&      my $delay = shift;
\&      Mojo::IOLoop\->timer(1 => $delay\->begin);
\&      Mojo::IOLoop\->timer(3 => $delay\->begin);
\&      say \*(AqThird step in 3 seconds.\*(Aq;
\&    },
\&
\&    # Third step (the end)
\&    sub { say \*(AqAnd done after 5 seconds total.\*(Aq }
\&  );
\&  $delay\->wait unless Mojo::IOLoop\->is_running;
.Ve
.SS "generate_port"
.IX Subsection "generate_port"
.Vb 2
\&  my $port = Mojo::IOLoop\->generate_port;
\&  my $port = $loop\->generate_port;
.Ve
.PP
Find a free \s-1TCP\s0 port, this is a utility function primarily used for tests.
.SS "is_running"
.IX Subsection "is_running"
.Vb 2
\&  my $bool = Mojo::IOLoop\->is_running;
\&  my $bool = $loop\->is_running;
.Ve
.PP
Check if event loop is running.
.PP
.Vb 1
\&  exit unless Mojo::IOLoop\->is_running;
.Ve
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 2
\&  Mojo::IOLoop\->one_tick;
\&  $loop\->one_tick;
.Ve
.PP
Run event loop until an event occurs. Note that this method can recurse back
into the reactor, so you need to be careful.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = Mojo::IOLoop\->timer(0.5 => sub {});
\&  Mojo::IOLoop\->one_tick;
\&  Mojo::IOLoop\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 2
\&  my $id = Mojo::IOLoop\->recurring(0.5 => sub {...});
\&  my $id = $loop\->recurring(3 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.PP
.Vb 2
\&  # Invoke as soon as possible
\&  Mojo::IOLoop\->recurring(0 => sub { say \*(AqReactor tick.\*(Aq });
.Ve
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  Mojo::IOLoop\->remove($id);
\&  $loop\->remove($id);
.Ve
.PP
Remove anything with an id, connections will be dropped gracefully by allowing
them to finish writing all data in their write buffers.
.SS "server"
.IX Subsection "server"
.Vb 3
\&  my $id = Mojo::IOLoop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server(port => 3000, sub {...});
\&  my $id = $loop\->server({port => 3000} => sub {...});
.Ve
.PP
Accept \s-1TCP\s0 connections with Mojo::IOLoop::Server, takes the same arguments
as \*(L"listen\*(R" in Mojo::IOLoop::Server.
.PP
.Vb 5
\&  # Listen on port 3000
\&  Mojo::IOLoop\->server({port => 3000} => sub {
\&    my ($loop, $stream, $id) = @_;
\&    ...
\&  });
.Ve
.SS "singleton"
.IX Subsection "singleton"
.Vb 1
\&  my $loop = Mojo::IOLoop\->singleton;
.Ve
.PP
The global Mojo::IOLoop singleton, used to access a single shared event
loop object from everywhere inside the process.
.PP
.Vb 3
\&  # Many methods also allow you to take shortcuts
\&  Mojo::IOLoop\->timer(2 => sub { Mojo::IOLoop\->stop });
\&  Mojo::IOLoop\->start;
\&
\&  # Restart active timer
\&  my $id = Mojo::IOLoop\->timer(3 => sub { say \*(AqTimeout!\*(Aq });
\&  Mojo::IOLoop\->singleton\->reactor\->again($id);
.Ve
.SS "start"
.IX Subsection "start"
.Vb 2
\&  Mojo::IOLoop\->start;
\&  $loop\->start;
.Ve
.PP
Start the event loop, this will block until \*(L"stop\*(R" is called. Note that
some reactors stop automatically if there are no events being watched anymore.
.PP
.Vb 2
\&  # Start event loop only if it is not running already
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 2
\&  Mojo::IOLoop\->stop;
\&  $loop\->stop;
.Ve
.PP
Stop the event loop, this will not interrupt any existing connections and the
event loop can be restarted by running \*(L"start\*(R" again.
.SS "stream"
.IX Subsection "stream"
.Vb 3
\&  my $stream = Mojo::IOLoop\->stream($id);
\&  my $stream = $loop\->stream($id);
\&  my $id     = $loop\->stream(Mojo::IOLoop::Stream\->new);
.Ve
.PP
Get Mojo::IOLoop::Stream object for id or turn object into a connection.
.PP
.Vb 2
\&  # Increase inactivity timeout for connection to 300 seconds
\&  Mojo::IOLoop\->stream($id)\->timeout(300);
.Ve
.SS "timer"
.IX Subsection "timer"
.Vb 3
\&  my $id = Mojo::IOLoop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(5 => sub {...});
\&  my $id = $loop\->timer(0.25 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.PP
.Vb 2
\&  # Invoke as soon as possible
\&  Mojo::IOLoop\->timer(0 => sub { say \*(AqNext tick.\*(Aq });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \s-1MOJO_IOLOOP_DEBUG\s0 environment variable to get some advanced
diagnostics information printed to \f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_IOLOOP_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
