.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::Collection 3"
.TH Mojo::Collection 3 "2013-11-19" "perl v5.16.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Collection \- Collection
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  # Manipulate collections
\&  use Mojo::Collection;
\&  my $collection = Mojo::Collection\->new(qw(just works));
\&  unshift @$collection, \*(Aqit\*(Aq;
\&  $collection\->map(sub { ucfirst })\->each(sub {
\&    my ($word, $count) = @_;
\&    say "$count: $word";
\&  });
\&
\&  # Use the alternative constructor
\&  use Mojo::Collection \*(Aqc\*(Aq;
\&  c(qw(a b c))\->join(\*(Aq/\*(Aq)\->url_escape\->say;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Collection is a container for collections.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mojo::Collection implements the following functions.
.SS "c"
.IX Subsection "c"
.Vb 1
\&  my $collection = c(1, 2, 3);
.Ve
.PP
Construct a new array-based Mojo::Collection object.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Collection implements the following methods.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $collection = Mojo::Collection\->new(1, 2, 3);
.Ve
.PP
Construct a new array-based Mojo::Collection object.
.SS "compact"
.IX Subsection "compact"
.Vb 1
\&  my $new = $collection\->compact;
.Ve
.PP
Create a new collection with all elements that are defined and not an empty
string.
.SS "each"
.IX Subsection "each"
.Vb 2
\&  my @elements = $collection\->each;
\&  $collection  = $collection\->each(sub {...});
.Ve
.PP
Evaluate callback for each element in collection or return all elements as a
list if none has been provided. The element will be the first argument passed
to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 4
\&  $collection\->each(sub {
\&    my ($e, $count) = @_;
\&    say "$count: $e";
\&  });
.Ve
.SS "first"
.IX Subsection "first"
.Vb 3
\&  my $first = $collection\->first;
\&  my $first = $collection\->first(qr/foo/);
\&  my $first = $collection\->first(sub {...});
.Ve
.PP
Evaluate regular expression or callback for each element in collection and
return the first one that matched the regular expression, or for which the
callback returned true. The element will be the first argument passed to the
callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $five = $collection\->first(sub { $_ == 5 });
.Ve
.SS "flatten"
.IX Subsection "flatten"
.Vb 1
\&  my $new = $collection\->flatten;
.Ve
.PP
Flatten nested collections/arrays recursively and create a new collection with
all elements.
.SS "grep"
.IX Subsection "grep"
.Vb 2
\&  my $new = $collection\->grep(qr/foo/);
\&  my $new = $collection\->grep(sub {...});
.Ve
.PP
Evaluate regular expression or callback for each element in collection and
create a new collection with all elements that matched the regular expression,
or for which the callback returned true. The element will be the first
argument passed to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $interesting = $collection\->grep(qr/mojo/i);
.Ve
.SS "join"
.IX Subsection "join"
.Vb 1
\&  my $stream = $collection\->join("\en");
.Ve
.PP
Turn collection into Mojo::ByteStream.
.PP
.Vb 1
\&  $collection\->join("\en")\->say;
.Ve
.SS "map"
.IX Subsection "map"
.Vb 1
\&  my $new = $collection\->map(sub {...});
.Ve
.PP
Evaluate callback for each element in collection and create a new collection
from the results. The element will be the first argument passed to the
callback and is also available as \f(CW$_\fR.
.PP
.Vb 1
\&  my $doubled = $collection\->map(sub { $_ * 2 });
.Ve
.SS "pluck"
.IX Subsection "pluck"
.Vb 2
\&  my $new = $collection\->pluck($method);
\&  my $new = $collection\->pluck($method, @args);
.Ve
.PP
Call method on each element in collection and create a new collection from the
results.
.PP
.Vb 2
\&  # Equal to but more convenient than
\&  my $new = $collection\->map(sub { $_\->$method(@args) });
.Ve
.SS "reverse"
.IX Subsection "reverse"
.Vb 1
\&  my $new = $collection\->reverse;
.Ve
.PP
Create a new collection with all elements in reverse order.
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  my $new = $collection\->slice(4 .. 7);
.Ve
.PP
Create a new collection with all selected elements.
.SS "shuffle"
.IX Subsection "shuffle"
.Vb 1
\&  my $new = $collection\->shuffle;
.Ve
.PP
Create a new collection with all elements in random order.
.SS "size"
.IX Subsection "size"
.Vb 1
\&  my $size = $collection\->size;
.Ve
.PP
Number of elements in collection.
.SS "sort"
.IX Subsection "sort"
.Vb 2
\&  my $new = $collection\->sort;
\&  my $new = $collection\->sort(sub {...});
.Ve
.PP
Sort elements based on return value of callback and create a new collection
from the results.
.PP
.Vb 1
\&  my $insensitive = $collection\->sort(sub { uc(shift) cmp uc(shift) });
.Ve
.SS "tap"
.IX Subsection "tap"
.Vb 1
\&  $collection = $collection\->tap(sub {...});
.Ve
.PP
Alias for \*(L"tap\*(R" in Mojo::Base.
.SS "uniq"
.IX Subsection "uniq"
.Vb 1
\&  my $new = $collection\->uniq;
.Ve
.PP
Create a new collection without duplicate elements.
.SH "ELEMENT METHODS"
.IX Header "ELEMENT METHODS"
In addition to the methods above, you can also call methods provided by all
elements in the collection directly and create a new collection from the
results, similar to \*(L"pluck\*(R".
.PP
.Vb 2
\&  push @$collection, Mojo::DOM\->new("<div><h1>$_</h1></div>") for 1 .. 9;
\&  say $collection\->at(\*(Aqh1\*(Aq)\->type(\*(Aqh2\*(Aq)\->prepend_content(\*(AqTest \*(Aq)\->root;
.Ve
.SH "ELEMENTS"
.IX Header "ELEMENTS"
Direct array reference access to elements is also possible.
.PP
.Vb 2
\&  say $collection\->[23];
\&  say for @$collection;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
